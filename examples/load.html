<!doctype html>
<html>
<head>
    <meta charset='utf-8'>
    <title>g2 - load</title>
</head>

<body>
    <h1>g2 - load</h1>
    <canvas id="c" width="400" height="300"></canvas>
    <script src='../../g2/g2.js'></script>
    <script src='../g2.mec.js'></script>
    <script>

/**
 * Polygonial line load. The first and last point define the base line onto which
 * the load is acting orthogonal.
 * @method
 * @returns {object} this
 * @param {array} pts Array of load contour points.
 * @param {real} spacing Spacing of the vectors drawn as a positive real number, interprete as<br>
 *                       * spacing &lt; 1: spacing = 1/m with a partition of m .
 *                       * spacing &gt; 1: length of spacing.
 * @param {object} [style] Arguments object.
 */
g2.prototype.load = function load(pts,spacing,style) {
   function iterator(p,dlambda) {
      var ux = pn.x - p0.x, uy = pn.y - p0.y, uu = ux*ux + uy*uy,
          lam = [], dlam, lambda = -dlambda;
console.log(dlambda);
      for (var i = 0; i < n; i++)  // build array of projection parameters of polypoints onto base line.
         lam[i] = ((pitr(p,i).x - p0.x)*ux + (pitr(p,i).y - p0.y)*uy)/uu;

      return {
         next: function() {
            lambda += dlambda;
            for (var i = 0; i < n; i++) {
               dlam = lam[i+1] - lam[i];
               if (dlam > 0 && lam[i] <= lambda && lambda <= lam[i+1]) {
                  var mu = (lambda - lam[i])/dlam;
                  return {
                     value: {
                        p1: {x:p0.x + lambda*ux,y:p0.y + lambda*uy},
                        p2: {x:pitr(p,i).x + mu*(pitr(p,i+1).x-pitr(p,i).x),y:pitr(p,i).y + mu*(pitr(p,i+1).y-pitr(p,i).y)}
                     }
                  }
               }
            }
            return { done: true };
         }
      };
   }

   var pitr = g2.prototype.ply.itrOf(pts), n = pitr(pts).count, p0 = pitr(pts,0), pn = pitr(pts,n-1),
       dlambda = spacing < 1 ? spacing : spacing/Math.hypot(pn.x-p0.x,pn.y-p0.y),
       itr = iterator(pts,dlambda), val;
   this.ply(pts,false,Object.assign({fs:"@linkfill"},style,{ls:"transparent"}));

   while (!(val = itr.next()).done)
      this.vec(val.value.p2,val.value.p1);

   return this;
}

g2().cartesian()
    .lin(100,200,300,200,{ls:"#aaa",lw:3})
    .load([150,200,180,240,250,240,250,200],20)
    .exe(document.getElementById("c").getContext("2d"));

   </script>
</body>
</html>
